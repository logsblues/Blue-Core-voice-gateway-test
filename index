/**
 * Core Voice Gateway v3.0.0 (Sandbox-first, enterprise-ready)
 * - Twilio Media Streams: WS /twilio-stream
 * - OpenAI Realtime: WS client
 * - Prewarm: POST /prewarm
 * - Inbound TwiML: POST /twilio/voice
 * - Outbound Calls: POST /twilio/outbound
 * - Transfer / End Call: tools + Twilio REST
 * - Tools: registry (mock by default), retries, circuit breaker, dedup
 * - Language: auto-detect EN/ES + guardrails
 * - Transcripts + optional Supabase sync (safe, never blocks calls)
 *
 * IMPORTANT: No Riverdom dependency. Everything is configurable per company/provider later.
 */

const http = require("http");
const crypto = require("crypto");
const { WebSocketServer, WebSocket } = require("ws");
const { v4: uuidv4 } = require("uuid");
const twilio = require("twilio");

// -------------------- ENV --------------------
const VERSION = "core-voice-gateway-v3.0.0-sandbox";
const PORT = process.env.PORT || 10000;
const NODE_ENV = process.env.NODE_ENV || "production";
const MODE = process.env.GATEWAY_MODE || "test"; // test|prod
const PUBLIC_BASE_URL = (process.env.PUBLIC_BASE_URL || "").replace(/\/$/, "");

// OpenAI Realtime
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";
const OPENAI_REALTIME_MODEL = process.env.OPENAI_REALTIME_MODEL || "gpt-4o-realtime-preview";

// Twilio
const TWILIO_ACCOUNT_SID = process.env.TWILIO_ACCOUNT_SID || "";
const TWILIO_AUTH_TOKEN = process.env.TWILIO_AUTH_TOKEN || "";
const TWILIO_FROM_NUMBER = process.env.TWILIO_FROM_NUMBER || "";

// Optional: Supabase REST (later)
const SUPABASE_URL = (process.env.SUPABASE_URL || "").replace(/\/$/, "");
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY || "";
const SUPABASE_CALLS_TABLE = process.env.SUPABASE_CALLS_TABLE || "calls";
const SUPABASE_TRANSCRIPTS_TABLE = process.env.SUPABASE_TRANSCRIPTS_TABLE || "call_transcripts";

// Behavior
const ENABLE_AUTO_DETECT_LANGUAGE = (process.env.ENABLE_AUTO_DETECT_LANGUAGE || "true") === "true";
const DEFAULT_LANGUAGE = (process.env.DEFAULT_LANGUAGE || "auto"); // auto|en|es
const LANGUAGE_LOCK_AFTER = parseInt(process.env.LANGUAGE_LOCK_AFTER || "2", 10); // lock after N user turns

const ENABLE_DEDUP = (process.env.ENABLE_DEDUP || "true") === "true";
const DEDUP_WINDOW_MS = parseInt(process.env.DEDUP_WINDOW_MS || "8000", 10);

const TOOL_TIMEOUT_MS = parseInt(process.env.TOOL_TIMEOUT_MS || "9000", 10);
const TOOL_RETRY_MAX = parseInt(process.env.TOOL_RETRY_MAX || "2", 10);

const CIRCUIT_FAILURE_THRESHOLD = parseInt(process.env.CIRCUIT_FAILURE_THRESHOLD || "5", 10);
const CIRCUIT_RESET_MS = parseInt(process.env.CIRCUIT_RESET_MS || "60000", 10);

// Logging
function log(level, msg, meta) {
  const payload = {
    ts: new Date().toISOString(),
    level,
    msg,
    ...meta
  };
  if (MODE === "test" || level !== "debug") {
    console.log(JSON.stringify(payload));
  }
}
const info = (m, meta) => log("info", m, meta);
const warn = (m, meta) => log("warn", m, meta);
const error = (m, meta) => log("error", m, meta);
const debug = (m, meta) => log("debug", m, meta);

function safeJsonParse(s) { try { return JSON.parse(s); } catch { return null; } }
function xmlEscape(s) {
  return String(s)
    .replace(/&/g, "&amp;").replace(/</g, "&lt;")
    .replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
function sha1(x) { return crypto.createHash("sha1").update(String(x)).digest("hex"); }
function withTimeout(promise, ms, label="timeout") {
  let t;
  const timeout = new Promise((_, rej) => t = setTimeout(() => rej(new Error(label)), ms));
  return Promise.race([promise.finally(() => clearTimeout(t)), timeout]);
}

// -------------------- Circuit Breaker --------------------
class CircuitBreaker {
  constructor(name) {
    this.name = name;
    this.state = "CLOSED"; // CLOSED|OPEN|HALF_OPEN
    this.failures = 0;
    this.nextAttemptAt = 0;
  }
  canRun() {
    if (this.state === "OPEN") {
      if (Date.now() >= this.nextAttemptAt) {
        this.state = "HALF_OPEN";
        info("circuit_half_open", { circuit: this.name });
        return true;
      }
      return false;
    }
    return true;
  }
  onSuccess() {
    if (this.state !== "CLOSED") info("circuit_closed", { circuit: this.name });
    this.state = "CLOSED";
    this.failures = 0;
    this.nextAttemptAt = 0;
  }
  onFailure() {
    this.failures += 1;
    warn("circuit_failure", { circuit: this.name, failures: this.failures, threshold: CIRCUIT_FAILURE_THRESHOLD });
    if (this.failures >= CIRCUIT_FAILURE_THRESHOLD) {
      this.state = "OPEN";
      this.nextAttemptAt = Date.now() + CIRCUIT_RESET_MS;
      error("circuit_opened", { circuit: this.name, reset_ms: CIRCUIT_RESET_MS });
    }
  }
  async execute(fn) {
    if (!this.canRun()) throw new Error(`Circuit ${this.name} is OPEN`);
    try {
      const out = await fn();
      this.onSuccess();
      return out;
    } catch (e) {
      this.onFailure();
      throw e;
    }
  }
}

// -------------------- Retry helper (backoff) --------------------
async function withRetry(fn, opts = {}) {
  const max = opts.max ?? TOOL_RETRY_MAX;
  const base = opts.baseMs ?? 120;
  const cap = opts.capMs ?? 1800;

  let lastErr;
  for (let attempt = 0; attempt <= max; attempt++) {
    try { return await fn(attempt); }
    catch (e) {
      lastErr = e;
      const isLast = attempt === max;
      if (isLast) break;
      const delay = Math.min(base * Math.pow(2, attempt) + Math.random() * 120, cap);
      warn("retrying", { attempt: attempt + 1, max, delay_ms: delay, err: e.message });
      await sleep(delay);
    }
  }
  throw lastErr;
}

// -------------------- Language detection (EN/ES) --------------------
const EN_HINTS = ["thank", "please", "yes", "no", "help", "appointment", "schedule", "tax", "today", "tomorrow", "morning", "afternoon"];
const ES_HINTS = ["gracias", "por favor", "sí", "no", "cita", "agendar", "impuestos", "hoy", "mañana", "buenos", "tardes"];
function detectLang(text) {
  const t = (text || "").toLowerCase();
  if (!t.trim()) return null;
  let en = 0, es = 0;
  for (const w of EN_HINTS) if (t.includes(w)) en++;
  for (const w of ES_HINTS) if (t.includes(w)) es++;
  if (en === 0 && es === 0) return null;
  if (en > es) return "en";
  if (es > en) return "es";
  return null;
}

// -------------------- Prompts + Guardrails --------------------
const BASE_PROMPT = `
You are a professional, friendly voice assistant.
Rules:
- Be concise, natural, and helpful.
- Ask one question at a time.
- Confirm critical details (name, phone, date/time).
- Use tools when appropriate.
- If a tool fails, apologize briefly and offer an alternative (take note / schedule later / transfer).
`.trim();

function buildSystemPrompt(session) {
  // Precedence (learned): base rules + company + campaign + dynamic
  const ops = `
Operational:
- Language policy:
  - auto_detect=${ENABLE_AUTO_DETECT_LANGUAGE}
  - default=${DEFAULT_LANGUAGE}
  - current=${session.language}
  - lock=${session.languageLocked}
- You MUST speak in ${session.language === "es" ? "Spanish" : "English"} unless told otherwise by system.
- If you detect user speaking the other language and auto_detect enabled, request permission to switch and then switch.
- If language is locked, DO NOT switch languages.
- Keep compliance and safety. No sensitive data collection beyond what's needed.
`.trim();

  const company = session.companyPrompt || "";
  const campaign = session.campaignScript || "";
  const dynamic = session.dynamicInstructions || "";

  return [BASE_PROMPT, ops, company, campaign, dynamic].filter(Boolean).join("\n\n").trim();
}

// -------------------- Sessions --------------------
const sessions = new Map(); // callSid/prewarmId -> session
function createSession(id) {
  return {
    id,
    callSid: null,
    streamSid: null,
    createdAt: Date.now(),
    direction: "inbound",
    fromNumber: null,
    toNumber: null,

    // language
    language: (DEFAULT_LANGUAGE === "en" || DEFAULT_LANGUAGE === "es") ? DEFAULT_LANGUAGE : "en",
    languageLocked: false,
    userTurns: 0,

    // prompts
    companyId: "sandbox",
    companyPrompt: "",
    campaignScript: "",
    dynamicInstructions: "",

    // transcripts
    transcripts: { user: [], assistant: [] },

    // tools
    toolHistory: new Map(), // dedupKey -> lastMs
    toolCallsInProgress: 0,

    // openai state
    speaking: false
  };
}
function getSession(id) {
  if (!sessions.has(id)) sessions.set(id, createSession(id));
  return sessions.get(id);
}

// -------------------- Tooling (Sandbox-first) --------------------
const circuitTools = new CircuitBreaker("tools");
const circuitSupabase = new CircuitBreaker("supabase");
const circuitTwilio = new CircuitBreaker("twilio");

// Tool registry: implement MANY tools (mock default)
const toolRegistry = {
  // Core CRM/ops tools
  lookup_contact: async (args, ctx) => mockOk("lookup_contact", args, ctx),
  create_lead: async (args, ctx) => mockOk("create_lead", args, ctx),
  update_contact: async (args, ctx) => mockOk("update_contact", args, ctx),
  take_note: async (args, ctx) => mockOk("take_note", args, ctx),

  // Messaging
  send_sms: async (args, ctx) => mockOk("send_sms", args, ctx),
  send_email: async (args, ctx) => mockOk("send_email", args, ctx),
  send_whatsapp: async (args, ctx) => mockOk("send_whatsapp", args, ctx),

  // Scheduling
  schedule_appointment: async (args, ctx) => mockOk("schedule_appointment", args, ctx),
  reschedule_appointment: async (args, ctx) => mockOk("reschedule_appointment", args, ctx),
  cancel_appointment: async (args, ctx) => mockOk("cancel_appointment", args, ctx),

  // Call control
  transfer_to_human: async (args, ctx) => transferToHuman(args, ctx),
  end_call: async (args, ctx) => endCall(args, ctx),

  // Extras (add as needed)
  set_language: async (args, ctx) => setLanguage(args, ctx),
  set_followup: async (args, ctx) => mockOk("set_followup", args, ctx)
};

function mockOk(name, args, ctx) {
  // Mock tools: no external calls. Safe for testing.
  info("tool_mock", { tool: name, callSid: ctx.callSid, args });
  return {
    ok: true,
    tool: name,
    mode: "mock",
    message: "Mock tool executed (no external connector).",
    echo: args || {}
  };
}

function toolDedupKey(name, args) {
  return `${name}:${sha1(JSON.stringify(args || {}))}`;
}

async function runTool(name, args, ctx) {
  if (!toolRegistry[name]) throw new Error(`Unknown tool: ${name}`);

  // Dedup (context-aware)
  if (ENABLE_DEDUP) {
    const k = toolDedupKey(name, args);
    const last = ctx.session.toolHistory.get(k);
    const now = Date.now();
    if (last && now - last < DEDUP_WINDOW_MS) {
      warn("tool_dedup_blocked", { tool: name, window_ms: DEDUP_WINDOW_MS, callSid: ctx.callSid });
      return { ok: true, deduped: true, tool: name, message: "Duplicate tool call suppressed." };
    }
    ctx.session.toolHistory.set(k, now);
  }

  ctx.session.toolCallsInProgress += 1;
  const started = Date.now();

  try {
    const res = await circuitTools.execute(() =>
      withRetry(async () => {
        const p = toolRegistry[name](args || {}, ctx);
        return await withTimeout(Promise.resolve(p), TOOL_TIMEOUT_MS, "tool_timeout");
      })
    );

    info("tool_ok", { tool: name, ms: Date.now() - started, callSid: ctx.callSid });
    return res;
  } finally {
    ctx.session.toolCallsInProgress = Math.max(0, ctx.session.toolCallsInProgress - 1);
  }
}

// -------------------- Twilio call control tools --------------------
function requireTwilio() {
  if (!TWILIO_ACCOUNT_SID || !TWILIO_AUTH_TOKEN) throw new Error("Missing TWILIO_ACCOUNT_SID/TWILIO_AUTH_TOKEN");
  return twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);
}

async function transferToHuman(args, ctx) {
  // args: { phone, whisper_message? }
  const phone = args.phone;
  if (!phone) return { ok: false, error: "transfer_to_human requires phone" };
  if (!ctx.callSid) return { ok: false, error: "No callSid available for transfer" };

  // Transfer on Twilio by updating call with TwiML <Dial>
  // NOTE: Media Streams transfer can be tricky; this does a hard redirect to Dial.
  const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Dial>${xmlEscape(phone)}</Dial>
</Response>`;

  try {
    const client = requireTwilio();
    await circuitTwilio.execute(async () => {
      await client.calls(ctx.callSid).update({ twiml });
    });
    info("transfer_requested", { callSid: ctx.callSid, to: phone });
    return { ok: true, transferred: true, to: phone };
  } catch (e) {
    error("transfer_failed", { callSid: ctx.callSid, err: e.message });
    return { ok: false, error: e.message, fallback: "Offer to take a message instead." };
  }
}

async function endCall(args, ctx) {
  if (!ctx.callSid) return { ok: false, error: "No callSid available to end call" };
  try {
    const client = requireTwilio();
    await circuitTwilio.execute(async () => {
      await client.calls(ctx.callSid).update({ status: "completed" });
    });
    info("call_ended", { callSid: ctx.callSid });
    return { ok: true, ended: true };
  } catch (e) {
    error("end_call_failed", { callSid: ctx.callSid, err: e.message });
    return { ok: false, error: e.message };
  }
}

function setLanguage(args, ctx) {
  const lang = String(args.language || "").toLowerCase();
  if (lang !== "en" && lang !== "es") return { ok: false, error: "language must be en or es" };
  ctx.session.language = lang;
  ctx.session.languageLocked = true;
  info("language_set_locked", { callSid: ctx.callSid, language: lang });
  return { ok: true, language: lang, locked: true };
}

// -------------------- Supabase optional (SAFE) --------------------
async function supabaseRest(path, method, body) {
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) throw new Error("Supabase ENV missing");
  const url = `${SUPABASE_URL}/rest/v1/${path}`;
  const res = await fetch(url, {
    method,
    headers: {
      "apikey": SUPABASE_SERVICE_ROLE_KEY,
      "Authorization": `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`,
      "Content-Type": "application/json",
      "Prefer": "return=representation"
    },
    body: body ? JSON.stringify(body) : undefined
  });
  const text = await res.text();
  const json = safeJsonParse(text);
  if (!res.ok) {
    const err = new Error(`Supabase ${method} ${path} failed (${res.status})`);
    err.details = { status: res.status, text: text.slice(0, 800) };
    throw err;
  }
  return json ?? { raw: text };
}

async function safeDbLogCall(session) {
  // MUST NEVER BREAK CALL if schema mismatches
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) return;

  const payload = {
    call_sid: session.callSid,
    company_id: session.companyId,
    direction: session.direction,
    from_number: session.fromNumber,
    to_number: session.toNumber,
    status: "in_progress",
    started_at: new Date().toISOString()
  };

  try {
    await circuitSupabase.execute(async () => {
      await withTimeout(
        withRetry(() => supabaseRest(`${SUPABASE_CALLS_TABLE}`, "POST", payload), { max: 1 }),
        5000,
        "db_timeout"
      );
    });
    info("db_call_logged", { callSid: session.callSid });
  } catch (e) {
    // This is exactly where v4.60.x failed; we log but never crash
    warn("db_call_log_failed_non_blocking", { callSid: session.callSid, err: e.message, details: e.details || null });
  }
}

async function safeDbSyncTranscripts(session) {
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) return;

  const combined = [];
  const maxLen = Math.max(session.transcripts.user.length, session.transcripts.assistant.length);
  for (let i = 0; i < maxLen; i++) {
    if (i < session.transcripts.user.length) combined.push({ role: "user", content: session.transcripts.user[i] });
    if (i < session.transcripts.assistant.length) combined.push({ role: "assistant", content: session.transcripts.assistant[i] });
  }
  if (combined.length === 0) {
    info("db_transcript_skip_empty", { callSid: session.callSid });
    return;
  }

  try {
    await circuitSupabase.execute(async () => {
      await withTimeout(
        withRetry(() => supabaseRest(`${SUPABASE_TRANSCRIPTS_TABLE}`, "POST", {
          call_sid: session.callSid,
          transcripts: combined,
          created_at: new Date().toISOString()
        }), { max: 1 }),
        7000,
        "db_timeout"
      );
    });
    info("db_transcripts_synced", { callSid: session.callSid, count: combined.length });
  } catch (e) {
    warn("db_transcripts_failed_non_blocking", { callSid: session.callSid, err: e.message, details: e.details || null });
  }
}

// -------------------- OpenAI Realtime connector --------------------
function connectOpenAI(session) {
  if (!OPENAI_API_KEY) throw new Error("Missing OPENAI_API_KEY");
  const url = `wss://api.openai.com/v1/realtime?model=${encodeURIComponent(OPENAI_REALTIME_MODEL)}`;

  const ws = new WebSocket(url, {
    headers: {
      Authorization: `Bearer ${OPENAI_API_KEY}`,
      "OpenAI-Beta": "realtime=v1"
    }
  });

  ws.on("open", () => {
    info("openai_connected", { callSid: session.callSid || session.id });

    const prompt = buildSystemPrompt(session);

    ws.send(JSON.stringify({
      type: "session.update",
      session: {
        instructions: prompt,
        input_audio_format: "g711_ulaw",
        output_audio_format: "g711_ulaw",
        voice: "alloy",
        tools: OPENAI_TOOL_SCHEMAS,
        tool_choice: "auto"
      }
    }));
  });

  ws.on("error", (e) => warn("openai_error", { callSid: session.callSid || session.id, err: e.message }));
  ws.on("close", (code, reason) => info("openai_closed", { callSid: session.callSid || session.id, code, reason: String(reason || "") }));

  return ws;
}

// Tools schemas exposed to OpenAI (many tools)
const OPENAI_TOOL_SCHEMAS = [
  { type: "function", name: "lookup_contact", description: "Lookup contact by name/phone/email in CRM.", parameters: { type: "object", properties: { phone:{type:"string"}, email:{type:"string"}, name:{type:"string"} }, required: [] } },
  { type: "function", name: "create_lead", description: "Create a new lead in CRM.", parameters: { type: "object", properties: { name:{type:"string"}, phone:{type:"string"}, email:{type:"string"}, notes:{type:"string"} }, required: [] } },
  { type: "function", name: "update_contact", description: "Update contact fields in CRM.", parameters: { type: "object", properties: { phone:{type:"string"}, fields:{type:"object"} }, required: ["fields"] } },
  { type: "function", name: "take_note", description: "Save a note for follow-up.", parameters: { type: "object", properties: { note:{type:"string"} }, required: ["note"] } },

  { type: "function", name: "send_sms", description: "Send SMS message.", parameters: { type: "object", properties: { phone:{type:"string"}, message:{type:"string"} }, required: ["phone","message"] } },
  { type: "function", name: "send_email", description: "Send email message.", parameters: { type: "object", properties: { email:{type:"string"}, subject:{type:"string"}, body:{type:"string"} }, required: ["email","subject","body"] } },
  { type: "function", name: "send_whatsapp", description: "Send WhatsApp message.", parameters: { type: "object", properties: { phone:{type:"string"}, message:{type:"string"} }, required: ["phone","message"] } },

  { type: "function", name: "schedule_appointment", description: "Schedule appointment.", parameters: { type: "object", properties: { phone:{type:"string"}, datetime_iso:{type:"string"}, notes:{type:"string"} }, required: ["datetime_iso"] } },
  { type: "function", name: "reschedule_appointment", description: "Reschedule appointment.", parameters: { type: "object", properties: { appointment_id:{type:"string"}, datetime_iso:{type:"string"} }, required: ["appointment_id","datetime_iso"] } },
  { type: "function", name: "cancel_appointment", description: "Cancel appointment.", parameters: { type: "object", properties: { appointment_id:{type:"string"}, reason:{type:"string"} }, required: ["appointment_id"] } },

  { type: "function", name: "transfer_to_human", description: "Transfer call to a human agent phone number.", parameters: { type: "object", properties: { phone:{type:"string"} }, required: ["phone"] } },
  { type: "function", name: "end_call", description: "End/hang up the call.", parameters: { type: "object", properties: { reason:{type:"string"} }, required: [] } },

  { type: "function", name: "set_language", description: "Set language and lock it.", parameters: { type: "object", properties: { language:{type:"string", enum:["en","es"]} }, required: ["language"] } },
  { type: "function", name: "set_followup", description: "Set follow-up reminder/task.", parameters: { type: "object", properties: { when_iso:{type:"string"}, note:{type:"string"} }, required: ["when_iso","note"] } }
];

// -------------------- Barge-in --------------------
function interruptIfSpeaking(session, openaiWs) {
  if (session.speaking && openaiWs && openaiWs.readyState === WebSocket.OPEN) {
    session.speaking = false;
    openaiWs.send(JSON.stringify({ type: "response.cancel" }));
    info("barge_in_cancel", { callSid: session.callSid });
  }
}

// -------------------- WebSocket server (Twilio Stream) --------------------
const wss = new WebSocketServer({ noServer: true });

wss.on("connection", (twilioWs) => {
  let openaiWs = null;
  let session = null;

  twilioWs.on("message", async (buf) => {
    const msg = safeJsonParse(buf.toString("utf8"));
    if (!msg) return;

    if (msg.event === "start") {
      const callSid = msg.start?.callSid || uuidv4();
      const streamSid = msg.start?.streamSid || null;

      session = getSession(callSid);
      session.callSid = callSid;
      session.streamSid = streamSid;

      const custom = msg.start?.customParameters || {};
      session.direction = custom.direction || "inbound";
      session.companyId = custom.company_id || "sandbox";
      session.fromNumber = custom.from || null;
      session.toNumber = custom.to || null;

      // Language initial
      const initLang = (custom.language || DEFAULT_LANGUAGE || "auto").toLowerCase();
      if (initLang === "es" || initLang === "en") session.language = initLang;
      if (initLang === "auto" && DEFAULT_LANGUAGE === "auto") session.language = "en"; // start EN, will auto-detect

      session.dynamicInstructions = custom.dynamic_instructions || "";

      info("twilio_start", { callSid, streamSid, companyId: session.companyId, direction: session.direction });

      // Optional: DB log call (non-blocking)
      safeDbLogCall(session);

      // Connect OpenAI
      try {
        openaiWs = connectOpenAI(session);
      } catch (e) {
        error("openai_connect_failed", { callSid, err: e.message });
      }

      if (openaiWs) {
        openaiWs.on("message", async (raw) => {
          const evt = safeJsonParse(raw.toString("utf8"));
          if (!evt) return;

          // Assistant audio
          if (evt.type === "response.audio.delta" && evt.delta) {
            session.speaking = true;
            if (twilioWs.readyState === WebSocket.OPEN) {
              twilioWs.send(JSON.stringify({ event: "media", streamSid: session.streamSid, media: { payload: evt.delta } }));
            }
            return;
          }
          if (evt.type === "response.done") {
            session.speaking = false;
            return;
          }

          // Transcripts (if provided by model events)
          if (evt.type === "response.output_text.delta" && evt.delta) {
            // optional: accumulate, but realtime often emits audio only; keep for completeness
            return;
          }

          // Tool calling
          if (evt.type === "response.function_call_arguments.done") {
            const toolName = evt.name;
            const args = safeJsonParse(evt.arguments || "{}") || {};

            info("tool_call", { callSid: session.callSid, tool: toolName });

            try {
              const out = await runTool(toolName, args, { callSid: session.callSid, session });
              openaiWs.send(JSON.stringify({
                type: "conversation.item.create",
                item: {
                  type: "function_call_output",
                  call_id: evt.call_id,
                  output: JSON.stringify(out)
                }
              }));
              openaiWs.send(JSON.stringify({ type: "response.create" }));
            } catch (e) {
              warn("tool_call_failed", { callSid: session.callSid, tool: toolName, err: e.message });
              openaiWs.send(JSON.stringify({
                type: "conversation.item.create",
                item: {
                  type: "function_call_output",
                  call_id: evt.call_id,
                  output: JSON.stringify({ ok: false, error: e.message, details: e.details || null })
                }
              }));
              openaiWs.send(JSON.stringify({ type: "response.create" }));
            }
            return;
          }

          if (evt.type === "error") {
            warn("openai_evt_error", { callSid: session.callSid, evt });
          }
        });

        openaiWs.on("close", async () => {
          // Sync transcripts non-blocking
          try { await safeDbSyncTranscripts(session); } catch {}
        });
      }

      return;
    }

    if (msg.event === "media") {
      if (!session || !openaiWs || openaiWs.readyState !== WebSocket.OPEN) return;

      // Barge-in
      interruptIfSpeaking(session, openaiWs);

      // Feed user audio
      const payload = msg.media?.payload;
      if (payload) {
        openaiWs.send(JSON.stringify({ type: "input_audio_buffer.append", audio: payload }));
      }
      return;
    }

    if (msg.event === "stop") {
      info("twilio_stop", { callSid: session?.callSid });
      try { if (openaiWs && openaiWs.readyState === WebSocket.OPEN) openaiWs.close(); } catch {}
      return;
    }
  });

  twilioWs.on("close", () => {
    try { if (openaiWs && openaiWs.readyState === WebSocket.OPEN) openaiWs.close(); } catch {}
  });

  twilioWs.on("error", (e) => warn("twilio_ws_error", { err: e.message }));
});

// -------------------- HTTP server --------------------
const server = http.createServer(async (req, res) => {
  // Basic routing
  if (req.method === "GET" && req.url === "/") {
    res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
    res.end(`
      <html><body style="font-family:Arial;padding:24px">
        <h2>${xmlEscape(VERSION)}</h2>
        <p>Running ✅</p>
        <ul>
          <li><a href="/health">/health</a></li>
          <li><a href="/ready">/ready</a></li>
          <li><a href="/version">/version</a></li>
        </ul>
      </body></html>
    `);
    return;
  }

  if (req.method === "GET" && req.url === "/version") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ version: VERSION, env: NODE_ENV, mode: MODE }));
    return;
  }

  if (req.method === "GET" && req.url === "/health") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({
      ok: true,
      version: VERSION,
      time: new Date().toISOString()
    }));
    return;
  }

  // readiness includes env sanity checks
  if (req.method === "GET" && req.url === "/ready") {
    const checks = {
      public_base_url: !!PUBLIC_BASE_URL,
      openai_key: !!OPENAI_API_KEY,
      twilio_sid: !!TWILIO_ACCOUNT_SID,
      twilio_token: !!TWILIO_AUTH_TOKEN,
      from_number: !!TWILIO_FROM_NUMBER
    };
    const ok = Object.values(checks).every(Boolean);
    res.writeHead(ok ? 200 : 503, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ ok, checks }));
    return;
  }

  // Prewarm: store dynamic instructions + desired language mode + company prompts
  if (req.method === "POST" && req.url === "/prewarm") {
    let body = "";
    req.on("data", (c) => body += c);
    req.on("end", () => {
      const data = safeJsonParse(body) || {};
      const prepId = data.prep_id || uuidv4();
      const s = getSession(prepId);

      s.companyId = data.company_id || s.companyId || "sandbox";
      s.companyPrompt = data.company_prompt || s.companyPrompt || "";
      s.campaignScript = data.campaign_script || s.campaignScript || "";
      s.dynamicInstructions = data.dynamic_instructions || s.dynamicInstructions || "";

      const lang = String(data.language || "auto").toLowerCase();
      if (lang === "en" || lang === "es") s.language = lang;
      // auto mode starts EN, switches when user speaks
      if (lang === "auto") s.language = "en";

      res.writeHead(200, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ ok: true, prep_id: prepId }));
    });
    return;
  }

  // Twilio inbound voice webhook -> TwiML streaming
  if (req.method === "POST" && req.url === "/twilio/voice") {
    if (!PUBLIC_BASE_URL) {
      res.writeHead(500, { "Content-Type": "text/plain" });
      res.end("Missing PUBLIC_BASE_URL");
      return;
    }
    const wsUrl = `${PUBLIC_BASE_URL.replace(/^http/, "ws")}/twilio-stream`;

    // NOTE: language can start "auto" by passing language=auto; session starts EN then auto-detect.
    const twiml = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Connect>
    <Stream url="${xmlEscape(wsUrl)}">
      <Parameter name="company_id" value="sandbox"/>
      <Parameter name="language" value="auto"/>
    </Stream>
  </Connect>
</Response>`;

    res.writeHead(200, { "Content-Type": "text/xml" });
    res.end(twiml);
    return;
  }

  // Outbound call trigger
  if (req.method === "POST" && req.url === "/twilio/outbound") {
    if (!PUBLIC_BASE_URL) {
      res.writeHead(500, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ ok: false, error: "Missing PUBLIC_BASE_URL" }));
      return;
    }
    if (!TWILIO_FROM_NUMBER) {
      res.writeHead(500, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ ok: false, error: "Missing TWILIO_FROM_NUMBER" }));
      return;
    }

    let body = "";
    req.on("data", (c) => body += c);
    req.on("end", async () => {
      const data = safeJsonParse(body) || {};
      const to = data.to;
      if (!to) {
        res.writeHead(400, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ ok: false, error: "Missing 'to'" }));
        return;
      }

      // Optional: prewarm session data (prep_id)
      const prepId = data.prep_id || uuidv4();
      const s = getSession(prepId);
      s.companyId = data.company_id || "sandbox";
      s.companyPrompt = data.company_prompt || "";
      s.campaignScript = data.campaign_script || "";
      s.dynamicInstructions = data.dynamic_instructions || "";

      const lang = String(data.language || "auto").toLowerCase();
      s.language = (lang === "es" || lang === "en") ? lang : "en";

      const voiceWebhook = `${PUBLIC_BASE_URL}/twilio/voice`;

      try {
        const client = requireTwilio();
        const call = await client.calls.create({
          to,
          from: TWILIO_FROM_NUMBER,
          url: voiceWebhook,
          method: "POST"
          // recording: set at Twilio number settings or add record=true in TwiML later
        });

        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ ok: true, call_sid: call.sid, prep_id: prepId }));
      } catch (e) {
        res.writeHead(500, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ ok: false, error: e.message }));
      }
    });
    return;
  }

  res.writeHead(404, { "Content-Type": "application/json" });
  res.end(JSON.stringify({ ok: false, error: "Not found", path: req.url }));
});

// Upgrade to WS
server.on("upgrade", (req, socket, head) => {
  if (!req.url || !req.url.startsWith("/twilio-stream")) return socket.destroy();
  wss.handleUpgrade(req, socket, head, (ws) => wss.emit("connection", ws, req));
});

server.listen(PORT, () => {
  console.log(`[START] ${VERSION} listening on ${PORT} env=${NODE_ENV} mode=${MODE}`);
  if (!PUBLIC_BASE_URL) warn("env_missing_public_base_url", {});
  if (!OPENAI_API_KEY) warn("env_missing_openai_key", {});
});
